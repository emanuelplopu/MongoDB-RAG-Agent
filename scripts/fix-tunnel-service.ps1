#Requires -RunAsAdministrator
# Fix Cloudflare Tunnel Service After Windows Restart
# This script properly configures the cloudflared service to use the correct config file
#
# Run as Administrator: Right-click PowerShell -> Run as Administrator
#                       cd d:\dev\repos\MongoDB-RAG-Agent
#                       .\scripts\fix-tunnel-service.ps1

$ErrorActionPreference = "Stop"

function Write-Header { param([string]$Msg) Write-Host "`n=== $Msg ===" -ForegroundColor Cyan }
function Write-Success { param([string]$Msg) Write-Host "[OK] $Msg" -ForegroundColor Green }
function Write-Info { param([string]$Msg) Write-Host "[INFO] $Msg" -ForegroundColor Yellow }
function Write-ErrorMsg { param([string]$Msg) Write-Host "[ERROR] $Msg" -ForegroundColor Red }

Write-Header "Cloudflare Tunnel Service Recovery"

# Check admin rights
$isAdmin = ([Security.Principal.WindowsPrincipal][Security.Principal.WindowsIdentity]::GetCurrent()).IsInRole([Security.Principal.WindowsBuiltInRole]::Administrator)
if (-not $isAdmin) {
    Write-ErrorMsg "This script must be run as Administrator!"
    Write-Info "Right-click PowerShell and select 'Run as Administrator'"
    exit 1
}
Write-Success "Running with Administrator privileges"

# Configuration
$serviceName = "cloudflared"
$userConfigDir = "$env:USERPROFILE\.cloudflared"
$systemConfigDir = "C:\Windows\System32\config\systemprofile\.cloudflared"
$userConfig = "$userConfigDir\config.yml"
$systemConfig = "$systemConfigDir\config.yml"

Write-Header "Step 1: Verifying Configuration Files"

# Check user config exists
if (-not (Test-Path $userConfig)) {
    Write-ErrorMsg "User config not found at $userConfig"
    Write-Info "Run .\setup-cloudflare-tunnel.ps1 first to create the tunnel"
    exit 1
}
Write-Success "User config found"

# Get tunnel ID from user config
$configContent = Get-Content $userConfig -Raw
if ($configContent -match "tunnel:\s*([a-f0-9-]+)") {
    $tunnelId = $matches[1]
    Write-Success "Tunnel ID: $tunnelId"
} else {
    Write-ErrorMsg "Could not find tunnel ID in config"
    exit 1
}

# Ensure system config directory exists
if (-not (Test-Path $systemConfigDir)) {
    New-Item -ItemType Directory -Path $systemConfigDir -Force | Out-Null
    Write-Success "Created system config directory"
}

Write-Header "Step 2: Copying Configuration to System Profile"

# Copy credentials file
$userCreds = "$userConfigDir\$tunnelId.json"
$systemCreds = "$systemConfigDir\$tunnelId.json"

if (Test-Path $userCreds) {
    Copy-Item -Path $userCreds -Destination $systemCreds -Force
    Write-Success "Copied credentials: $tunnelId.json"
} else {
    Write-ErrorMsg "Credentials file not found: $userCreds"
    exit 1
}

# Create system config with absolute paths
$systemConfigContent = @"
# RecallHub Cloudflare Tunnel Configuration (System Service)
# Auto-generated by fix-tunnel-service.ps1
# Generated: $(Get-Date -Format 'yyyy-MM-dd HH:mm:ss')

tunnel: $tunnelId
credentials-file: $systemCreds

# Metrics for monitoring
metrics: localhost:60123

ingress:
  # Backend API - api.recallhub.app
  - hostname: api.recallhub.app
    service: http://localhost:11000
    originRequest:
      noTLSVerify: true
      connectTimeout: 30s
      keepAliveTimeout: 90s

  # Frontend - www.recallhub.app
  - hostname: www.recallhub.app
    service: http://localhost:11080
    originRequest:
      noTLSVerify: true

  # Frontend - recallhub.app (root domain)
  - hostname: recallhub.app
    service: http://localhost:11080
    originRequest:
      noTLSVerify: true

  # Catch-all rule (required by cloudflared)
  - service: http_status:404
"@

$systemConfigContent | Out-File -FilePath $systemConfig -Encoding utf8 -Force
Write-Success "Created system config at $systemConfig"

Write-Header "Step 3: Reinstalling Service"

# Stop and uninstall existing service
$service = Get-Service $serviceName -ErrorAction SilentlyContinue
if ($service) {
    Write-Info "Stopping existing service..."
    Stop-Service $serviceName -Force -ErrorAction SilentlyContinue
    Start-Sleep -Seconds 2
    
    Write-Info "Uninstalling existing service..."
    & cloudflared service uninstall 2>&1 | Out-Null
    Start-Sleep -Seconds 2
}

# Install service
Write-Info "Installing cloudflared service..."
& cloudflared service install 2>&1 | Out-Null

if ($LASTEXITCODE -ne 0) {
    Write-ErrorMsg "Service installation failed"
    exit 1
}
Write-Success "Service installed"

Write-Header "Step 4: Configuring Service Recovery"

# Configure recovery options
# Reset failure count after 1 day (86400 seconds)
# Actions: restart after 5 sec, restart after 10 sec, restart after 30 sec
$null = sc.exe failure $serviceName reset= 86400 actions= restart/5000/restart/10000/restart/30000
if ($LASTEXITCODE -eq 0) {
    Write-Success "Configured automatic restart on failure"
} else {
    Write-Info "Could not configure recovery options (non-critical)"
}

# Set service to delayed auto-start
$null = sc.exe config $serviceName start= delayed-auto
if ($LASTEXITCODE -eq 0) {
    Write-Success "Configured delayed auto-start"
} else {
    Write-Info "Could not set delayed auto-start (non-critical)"
}

Write-Header "Step 5: Starting Service"

Start-Service $serviceName
Start-Sleep -Seconds 5

$service = Get-Service $serviceName
if ($service.Status -eq 'Running') {
    Write-Success "Service started successfully!"
} else {
    Write-ErrorMsg "Service failed to start. Status: $($service.Status)"
    Write-Info "Checking recent errors..."
    
    # Show recent application log errors
    Get-WinEvent -LogName Application -MaxEvents 5 -ErrorAction SilentlyContinue | 
        Where-Object { $_.Message -like "*cloudflared*" } | 
        ForEach-Object {
            Write-Host "  [$($_.TimeCreated)] $($_.LevelDisplayName): $($_.Message.Split("`n")[0])" -ForegroundColor Yellow
        }
    exit 1
}

Write-Header "Step 6: Verifying Connectivity"

Start-Sleep -Seconds 3

# Test frontend
try {
    $response = Invoke-WebRequest -Uri "https://recallhub.app" -TimeoutSec 15 -UseBasicParsing
    Write-Success "Frontend accessible: HTTP $($response.StatusCode)"
} catch {
    Write-Info "Frontend check: $($_.Exception.Message)"
}

# Test API
try {
    $response = Invoke-WebRequest -Uri "https://api.recallhub.app/health" -TimeoutSec 15 -UseBasicParsing
    Write-Success "API accessible: HTTP $($response.StatusCode)"
} catch {
    Write-Info "API check (may fail if backend not running): $($_.Exception.Message)"
}

Write-Header "Final Status"

$service = Get-Service $serviceName
Write-Host "Service Name:  $($service.Name)"
Write-Host "Status:        $($service.Status)" -ForegroundColor $(if ($service.Status -eq 'Running') { 'Green' } else { 'Red' })
Write-Host "Start Type:    $($service.StartType)"
Write-Host ""
Write-Host "Configuration: $systemConfig"
Write-Host "Credentials:   $systemCreds"
Write-Host ""

if ($service.Status -eq 'Running') {
    Write-Success "Tunnel is now running and will auto-start after Windows restarts!"
    Write-Host ""
    Write-Host "Endpoints:" -ForegroundColor Cyan
    Write-Host "  https://recallhub.app     (Frontend)"
    Write-Host "  https://www.recallhub.app (Frontend)"
    Write-Host "  https://api.recallhub.app (Backend API)"
} else {
    Write-ErrorMsg "Service is not running. Check the logs above for errors."
}

Write-Host ""
