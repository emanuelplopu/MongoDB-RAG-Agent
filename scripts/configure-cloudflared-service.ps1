#Requires -RunAsAdministrator
# Configure Cloudflared Windows Service with Robust Recovery Options
# Run this script as Administrator to configure the service properly
#
# Usage: Right-click PowerShell -> Run as Administrator
#        .\scripts\configure-cloudflared-service.ps1

param(
    [switch]$UpdateBinary,
    [switch]$Force
)

$ErrorActionPreference = "Stop"

function Write-Header { param([string]$Msg) Write-Host "`n=== $Msg ===" -ForegroundColor Cyan }
function Write-Success { param([string]$Msg) Write-Host "[OK] $Msg" -ForegroundColor Green }
function Write-Info { param([string]$Msg) Write-Host "[INFO] $Msg" -ForegroundColor Yellow }
function Write-ErrorMsg { param([string]$Msg) Write-Host "[ERROR] $Msg" -ForegroundColor Red }

Write-Header "Cloudflared Service Configuration"

# Check admin rights
$isAdmin = ([Security.Principal.WindowsPrincipal][Security.Principal.WindowsIdentity]::GetCurrent()).IsInRole([Security.Principal.WindowsBuiltInRole]::Administrator)
if (-not $isAdmin) {
    Write-ErrorMsg "This script must be run as Administrator!"
    Write-Info "Right-click PowerShell and select 'Run as Administrator'"
    exit 1
}
Write-Success "Running with Administrator privileges"

# Configuration
$serviceName = "cloudflared"
$configDir = "$env:USERPROFILE\.cloudflared"
$systemConfigDir = "C:\Windows\System32\config\systemprofile\.cloudflared"
$projectRoot = Split-Path -Parent $PSScriptRoot

# Step 1: Update cloudflared binary (optional)
if ($UpdateBinary) {
    Write-Header "Updating Cloudflared Binary"
    
    $service = Get-Service $serviceName -ErrorAction SilentlyContinue
    if ($service -and $service.Status -eq 'Running') {
        Write-Info "Stopping service for update..."
        Stop-Service $serviceName -Force
        Start-Sleep -Seconds 2
    }
    
    $latestUrl = "https://github.com/cloudflare/cloudflared/releases/latest/download/cloudflared-windows-amd64.exe"
    $destPath = "C:\Program Files (x86)\cloudflared\cloudflared.exe"
    $tempPath = "$env:TEMP\cloudflared-new.exe"
    
    Write-Info "Downloading latest cloudflared..."
    try {
        Invoke-WebRequest -Uri $latestUrl -OutFile $tempPath -UseBasicParsing
        
        # Backup old version
        if (Test-Path $destPath) {
            $backupPath = "$destPath.bak"
            Copy-Item -Path $destPath -Destination $backupPath -Force
            Write-Info "Backed up old version to $backupPath"
        }
        
        # Copy new version
        Copy-Item -Path $tempPath -Destination $destPath -Force
        $newVersion = & $destPath --version 2>&1 | Select-String -Pattern '\d+\.\d+\.\d+'
        Write-Success "Updated cloudflared to: $newVersion"
        
        Remove-Item $tempPath -Force -ErrorAction SilentlyContinue
    }
    catch {
        Write-ErrorMsg "Failed to update: $($_.Exception.Message)"
    }
}

# Step 2: Ensure configuration files exist in system profile
Write-Header "Configuring System Profile"

if (-not (Test-Path $systemConfigDir)) {
    New-Item -ItemType Directory -Path $systemConfigDir -Force | Out-Null
    Write-Success "Created system config directory"
}

# Get tunnel ID from user config
$userConfig = "$configDir\config.yml"
if (-not (Test-Path $userConfig)) {
    Write-ErrorMsg "User config not found at $userConfig"
    Write-Info "Run setup-cloudflare-tunnel.ps1 first to create the tunnel"
    exit 1
}

$configContent = Get-Content $userConfig -Raw
if ($configContent -match "tunnel:\s*([a-f0-9-]+)") {
    $tunnelId = $matches[1]
    Write-Success "Found tunnel ID: $tunnelId"
} else {
    Write-ErrorMsg "Could not find tunnel ID in config"
    exit 1
}

# Copy credentials file
$userCreds = "$configDir\$tunnelId.json"
$systemCreds = "$systemConfigDir\$tunnelId.json"

if (Test-Path $userCreds) {
    Copy-Item -Path $userCreds -Destination $systemCreds -Force
    Write-Success "Copied credentials to system profile"
} else {
    Write-ErrorMsg "Credentials file not found: $userCreds"
    exit 1
}

# Generate system-appropriate config
$systemConfig = @"
# RecallHub Cloudflare Tunnel Configuration (System Service)
# Auto-generated by configure-cloudflared-service.ps1
# Generated: $(Get-Date -Format 'yyyy-MM-dd HH:mm:ss')

tunnel: $tunnelId
credentials-file: $systemCreds

# Metrics for monitoring
metrics: localhost:60123

ingress:
  # Backend API - api.recallhub.app
  - hostname: api.recallhub.app
    service: http://localhost:11000
    originRequest:
      noTLSVerify: true
      connectTimeout: 30s
      keepAliveTimeout: 90s

  # Frontend - www.recallhub.app
  - hostname: www.recallhub.app
    service: http://localhost:11080
    originRequest:
      noTLSVerify: true

  # Frontend - recallhub.app (root domain)
  - hostname: recallhub.app
    service: http://localhost:11080
    originRequest:
      noTLSVerify: true

  # Catch-all rule (required by cloudflared)
  - service: http_status:404
"@

$systemConfig | Out-File -FilePath "$systemConfigDir\config.yml" -Encoding utf8 -Force
Write-Success "Created system config at $systemConfigDir\config.yml"

# Step 3: Configure service recovery options
Write-Header "Configuring Service Recovery"

$service = Get-Service $serviceName -ErrorAction SilentlyContinue
if (-not $service) {
    Write-Info "Service not installed. Installing..."
    & cloudflared service install
    Start-Sleep -Seconds 2
    $service = Get-Service $serviceName
}

# Stop service for configuration
if ($service.Status -eq 'Running') {
    Stop-Service $serviceName -Force
    Start-Sleep -Seconds 2
}

# Configure recovery options using sc.exe
# Reset failure count after 1 day (86400 seconds)
# Actions: restart after 5 sec, restart after 10 sec, restart after 30 sec
$result = sc.exe failure $serviceName reset= 86400 actions= restart/5000/restart/10000/restart/30000
if ($LASTEXITCODE -eq 0) {
    Write-Success "Configured automatic restart on failure (5s, 10s, 30s intervals)"
} else {
    Write-ErrorMsg "Failed to configure recovery options"
}

# Set service to delayed auto-start (more reliable on boot)
$result = sc.exe config $serviceName start= delayed-auto
if ($LASTEXITCODE -eq 0) {
    Write-Success "Configured delayed auto-start"
} else {
    Write-Info "Could not set delayed auto-start (non-critical)"
}

# Step 4: Start the service
Write-Header "Starting Service"

Start-Service $serviceName
Start-Sleep -Seconds 3

$service = Get-Service $serviceName
if ($service.Status -eq 'Running') {
    Write-Success "Service started successfully!"
} else {
    Write-ErrorMsg "Service failed to start. Status: $($service.Status)"
    Write-Info "Check Windows Event Viewer for details"
}

# Step 5: Verify connectivity
Write-Header "Verifying Connectivity"
Start-Sleep -Seconds 5  # Give tunnel time to establish connections

try {
    $response = Invoke-WebRequest -Uri "https://recallhub.app" -TimeoutSec 15 -UseBasicParsing
    Write-Success "Frontend accessible: Status $($response.StatusCode)"
} catch {
    Write-Info "Frontend check: $($_.Exception.Message)"
}

try {
    $response = Invoke-WebRequest -Uri "https://api.recallhub.app/health" -TimeoutSec 15 -UseBasicParsing
    Write-Success "API accessible: Status $($response.StatusCode)"
} catch {
    Write-Info "API check (may fail if backend not running): $($_.Exception.Message)"
}

# Final status
Write-Header "Final Status"
$service = Get-Service $serviceName
Write-Host "Service Name: $($service.Name)"
Write-Host "Status: $($service.Status)"
Write-Host "Start Type: $($service.StartType)"

# Show recovery configuration
$recoveryInfo = sc.exe qfailure $serviceName
Write-Host "`nRecovery Configuration:"
$recoveryInfo | Where-Object { $_ -match "RESET_PERIOD|REBOOT_MESSAGE|COMMAND_LINE|FAILURE_ACTIONS" } | ForEach-Object { Write-Host "  $_" }

Write-Host ""
Write-Success "Configuration complete! The tunnel should now survive reboots and auto-recover from failures."
Write-Host ""
